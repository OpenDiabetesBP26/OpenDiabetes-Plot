"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const compiler_1 = __importDefault(require("../compiler"));
const connection_1 = __importDefault(require("../browser/connection"));
const runtime_1 = require("../errors/runtime");
const pool_1 = __importDefault(require("../browser/provider/pool"));
const types_1 = require("../errors/types");
const browser_set_1 = __importDefault(require("./browser-set"));
const tested_app_1 = __importDefault(require("./tested-app"));
const parse_file_list_1 = __importDefault(require("../utils/parse-file-list"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const make_dir_1 = __importDefault(require("make-dir"));
const resolve_path_relatively_cwd_1 = __importDefault(require("../utils/resolve-path-relatively-cwd"));
const load_1 = __importDefault(require("../custom-client-scripts/load"));
class Bootstrapper {
    constructor(browserConnectionGateway) {
        this.browserConnectionGateway = browserConnectionGateway;
        this.concurrency = null;
        this.sources = [];
        this.browsers = [];
        this.reporters = [];
        this.filter = null;
        this.appCommand = null;
        this.appInitDelay = null;
        this.tsConfigPath = null;
        this.clientScripts = [];
        this.allowMultipleWindows = false;
    }
    static _splitBrowserInfo(browserInfo) {
        const remotes = [];
        const automated = [];
        browserInfo.forEach(browser => {
            if (browser instanceof connection_1.default)
                remotes.push(browser);
            else
                automated.push(browser);
        });
        return { remotes, automated };
    }
    async _getBrowserInfo() {
        if (!this.browsers.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.browserNotSet);
        const browserInfo = await Promise.all(this.browsers.map(browser => pool_1.default.getBrowserInfo(browser)));
        return lodash_1.flatten(browserInfo);
    }
    _createAutomatedConnections(browserInfo) {
        if (!browserInfo)
            return [];
        return browserInfo
            .map(browser => lodash_1.times(this.concurrency, () => new connection_1.default(this.browserConnectionGateway, browser, false, this.allowMultipleWindows)));
    }
    async _getBrowserConnections(browserInfo) {
        const { automated, remotes } = Bootstrapper._splitBrowserInfo(browserInfo);
        if (remotes && remotes.length % this.concurrency)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency);
        let browserConnections = this._createAutomatedConnections(automated);
        browserConnections = browserConnections.concat(lodash_1.chunk(remotes, this.concurrency));
        return await browser_set_1.default.from(browserConnections);
    }
    async _getTests() {
        const { parsedFileList, compilerOptions } = await this._getCompilerArguments();
        if (!parsedFileList.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.testFilesNotFound);
        const compiler = new compiler_1.default(parsedFileList, compilerOptions);
        let tests = await compiler.getTests();
        const testsWithOnlyFlag = tests.filter(test => test.only);
        if (testsWithOnlyFlag.length)
            tests = testsWithOnlyFlag;
        if (this.filter)
            tests = tests.filter(test => this.filter(test.name, test.fixture.name, test.fixture.path, test.meta, test.fixture.meta));
        if (!tests.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.noTestsToRun);
        return tests;
    }
    async _getCompilerArguments() {
        const parsedFileList = await parse_file_list_1.default(this.sources, process.cwd());
        const compilerOptions = {
            typeScriptOptions: {
                tsConfigPath: this.tsConfigPath
            }
        };
        return { parsedFileList, compilerOptions };
    }
    async _ensureOutStream(outStream) {
        if (typeof outStream !== 'string')
            return outStream;
        const fullReporterOutputPath = resolve_path_relatively_cwd_1.default(outStream);
        await make_dir_1.default(path_1.default.dirname(fullReporterOutputPath));
        return fs_1.default.createWriteStream(fullReporterOutputPath);
    }
    static _addDefaultReporter(reporters) {
        reporters.push({
            name: 'spec',
            file: process.stdout
        });
    }
    async _getReporterPlugins() {
        const stdoutReporters = lodash_1.filter(this.reporters, r => lodash_1.isUndefined(r.output) || r.output === process.stdout);
        if (stdoutReporters.length > 1)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.multipleStdoutReporters, stdoutReporters.map(r => r.name).join(', '));
        if (!this.reporters.length)
            Bootstrapper._addDefaultReporter(this.reporters);
        return Promise.all(this.reporters.map(async ({ name, output }) => {
            let pluginFactory = name;
            const outStream = await this._ensureOutStream(output);
            if (typeof pluginFactory !== 'function') {
                try {
                    pluginFactory = require('testcafe-reporter-' + name);
                }
                catch (err) {
                    throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotFindReporterForAlias, name);
                }
            }
            return {
                plugin: pluginFactory(),
                outStream
            };
        }));
    }
    async _startTestedApp() {
        if (this.appCommand) {
            const testedApp = new tested_app_1.default();
            await testedApp.start(this.appCommand, this.appInitDelay);
            return testedApp;
        }
        return null;
    }
    async _canUseParallelBootstrapping(browserInfo) {
        const isLocalPromises = browserInfo.map(browser => browser.provider.isLocalBrowser(null, browserInfo.browserName));
        const isLocalBrowsers = await Promise.all(isLocalPromises);
        return isLocalBrowsers.every(result => result);
    }
    async _bootstrapSequence(browserInfo) {
        const tests = await this._getTests();
        const testedApp = await this._startTestedApp();
        const browserSet = await this._getBrowserConnections(browserInfo);
        return { tests, testedApp, browserSet };
    }
    _wrapBootstrappingPromise(promise) {
        return promise
            .then(result => ({ error: null, result }))
            .catch(error => ({ result: null, error }));
    }
    async _handleBootstrappingError([browserSetStatus, testsStatus, testedAppStatus]) {
        if (!browserSetStatus.error)
            await browserSetStatus.result.dispose();
        if (!testedAppStatus.error && testedAppStatus.result)
            await testedAppStatus.result.kill();
        if (testsStatus.error)
            throw testsStatus.error;
        else if (testedAppStatus.error)
            throw testedAppStatus.error;
        else
            throw browserSetStatus.error;
    }
    async _bootstrapParallel(browserInfo) {
        let bootstrappingPromises = [
            this._getBrowserConnections(browserInfo),
            this._getTests(),
            this._startTestedApp()
        ];
        bootstrappingPromises = bootstrappingPromises.map(promise => this._wrapBootstrappingPromise(promise));
        const bootstrappingStatuses = await Promise.all(bootstrappingPromises);
        if (bootstrappingStatuses.some(status => status.error))
            await this._handleBootstrappingError(bootstrappingStatuses);
        const [browserSet, tests, testedApp] = bootstrappingStatuses.map(status => status.result);
        return { browserSet, tests, testedApp };
    }
    // API
    async createRunnableConfiguration() {
        const reporterPlugins = await this._getReporterPlugins();
        const commonClientScripts = await load_1.default(this.clientScripts);
        // NOTE: If a user forgot to specify a browser, but has specified a path to tests, the specified path will be
        // considered as the browser argument, and the tests path argument will have the predefined default value.
        // It's very ambiguous for the user, who might be confused by compilation errors from an unexpected test.
        // So, we need to retrieve the browser aliases and paths before tests compilation.
        const browserInfo = await this._getBrowserInfo();
        if (await this._canUseParallelBootstrapping(browserInfo))
            return Object.assign(Object.assign({ reporterPlugins }, await this._bootstrapParallel(browserInfo)), { commonClientScripts });
        return Object.assign(Object.assign({ reporterPlugins }, await this._bootstrapSequence(browserInfo)), { commonClientScripts });
    }
}
exports.default = Bootstrapper;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bm5lci9ib290c3RyYXBwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxtQ0FBb0U7QUFDcEUsMkRBQW1DO0FBQ25DLHVFQUFzRDtBQUN0RCwrQ0FBaUQ7QUFDakQsb0VBQTJEO0FBQzNELDJDQUFpRDtBQUNqRCxnRUFBdUM7QUFDdkMsOERBQXFDO0FBQ3JDLCtFQUFxRDtBQUNyRCxnREFBd0I7QUFDeEIsNENBQW9CO0FBQ3BCLHdEQUErQjtBQUMvQix1R0FBNEU7QUFDNUUseUVBQThEO0FBRTlELE1BQXFCLFlBQVk7SUFDN0IsWUFBYSx3QkFBd0I7UUFDakMsSUFBSSxDQUFDLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO1FBQ3pELElBQUksQ0FBQyxXQUFXLEdBQWdCLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsT0FBTyxHQUFvQixFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBbUIsRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxTQUFTLEdBQWtCLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsTUFBTSxHQUFxQixJQUFJLENBQUM7UUFDckMsSUFBSSxDQUFDLFVBQVUsR0FBaUIsSUFBSSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxZQUFZLEdBQWUsSUFBSSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxZQUFZLEdBQWUsSUFBSSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxhQUFhLEdBQWMsRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxvQkFBb0IsR0FBTyxLQUFLLENBQUM7SUFDMUMsQ0FBQztJQUVELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBRSxXQUFXO1FBQ2pDLE1BQU0sT0FBTyxHQUFLLEVBQUUsQ0FBQztRQUNyQixNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFFckIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtZ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eUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRWhFLE1BQU0sQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxHQUFHLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUxRixPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQsTUFBTTtJQUNOLEtBQUssQ0FBQywyQkFBMkI7UUFDN0IsTUFBTSxlQUFlLEdBQU8sTUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUM3RCxNQUFNLG1CQUFtQixHQUFHLE1BQU0sY0FBaUIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFeEUsNkdBQTZHO1FBQzdHLDBHQUEwRztRQUMxRyx5R0FBeUc7UUFDekcsa0ZBQWtGO1FBQ2xGLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRWpELElBQUksTUFBTSxJQUFJLENBQUMsNEJBQTRCLENBQUMsV0FBVyxDQUFDO1lBQ3BELHFDQUFTLGVBQWUsSUFBSyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsS0FBRSxtQkFBbUIsSUFBRztRQUVuRyxxQ0FBUyxlQUFlLElBQUssTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLEtBQUUsbUJBQW1CLElBQUc7SUFDbkcsQ0FBQztDQUNKO0FBak9ELCtCQWlPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVW5kZWZpbmVkLCBmaWx0ZXIsIGZsYXR0ZW4sIGNodW5rLCB0aW1lcyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQ29tcGlsZXIgZnJvbSAnLi4vY29tcGlsZXInO1xuaW1wb3J0IEJyb3dzZXJDb25uZWN0aW9uIGZyb20gJy4uL2Jyb3dzZXIvY29ubmVjdGlvbic7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgYnJvd3NlclByb3ZpZGVyUG9vbCBmcm9tICcuLi9icm93c2VyL3Byb3ZpZGVyL3Bvb2wnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi9lcnJvcnMvdHlwZXMnO1xuaW1wb3J0IEJyb3dzZXJTZXQgZnJvbSAnLi9icm93c2VyLXNldCc7XG5pbXBvcnQgVGVzdGVkQXBwIGZyb20gJy4vdGVzdGVkLWFwcCc7XG5pbXBvcnQgcGFyc2VGaWxlTGlzdCBmcm9tICcuLi91dGlscy9wYXJzZS1maWxlLWxpc3QnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IG1ha2VEaXIgZnJvbSAnbWFrZS1kaXInO1xuaW1wb3J0IHJlc29sdmVQYXRoUmVsYXRpdmVseUN3ZCBmcm9tICcuLi91dGlscy9yZXNvbHZlLXBhdGgtcmVsYXRpdmVseS1jd2QnO1xuaW1wb3J0IGxvYWRDbGllbnRTY3JpcHRzIGZyb20gJy4uL2N1c3RvbS1jbGllbnQtc2NyaXB0cy9sb2FkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9vdHN0cmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoYnJvd3NlckNvbm5lY3Rpb25HYXRld2F5KSB7XG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25HYXRld2F5ID0gYnJvd3NlckNvbm5lY3Rpb25HYXRld2F5O1xuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlcyAgICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuYnJvd3NlcnMgICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMucmVwb3J0ZXJzICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuZmlsdGVyICAgICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHBDb21tYW5kICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcEluaXREZWxheSAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudHNDb25maWdQYXRoICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGllbnRTY3JpcHRzICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxvd011bHRpcGxlV2luZG93cyAgICAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX3NwbGl0QnJvd3NlckluZm8gKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZXMgICA9IFtdO1xuICAgICAgICBjb25zdCBhdXRvbWF0ZWQgPSBbXTtcblxuICAgICAgICBicm93c2VySW5mby5mb3JFYWNoKGJyb3dzZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIgaW5zdGFuY2VvZiBCcm93c2VyQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICByZW1vdGVzLnB1c2goYnJvd3Nlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXV0b21hdGVkLnB1c2goYnJvd3Nlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHJlbW90ZXMsIGF1dG9tYXRlZCB9O1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRCcm93c2VySW5mbyAoKSB7XG4gICAgICAgIGlmICghdGhpcy5icm93c2Vycy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmJyb3dzZXJOb3RTZXQpO1xuXG4gICAgICAgIGNvbnN0IGJyb3dzZXJJbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5icm93c2Vycy5tYXAoYnJvd3NlciA9PiBicm93c2VyUHJvdmlkZXJQb29sLmdldEJyb3dzZXJJbmZvKGJyb3dzZXIpKSk7XG5cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYnJvd3NlckluZm8pO1xuICAgIH1cblxuICAgIF9jcmVhdGVBdXRvbWF0ZWRDb25uZWN0aW9ucyAoYnJvd3NlckluZm8pIHtcbiAgICAgICAgaWYgKCFicm93c2VySW5mbylcbiAgICAgICAgICAgIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gYnJvd3NlckluZm9cbiAgICAgICAgICAgIC5tYXAoYnJvd3NlciA9PiB0aW1lcyh0aGlzLmNvbmN1cnJlbmN5LCAoKSA9PiBuZXcgQnJvd3NlckNvbm5lY3Rpb24odGhpcy5icm93c2VyQ29ubmVjdGlvbkdhdGV3YXksIGJyb3dzZXIsIGZhbHNlLCB0aGlzLmFsbG93TXVsdGlwbGVXaW5kb3dzKSkpO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRCcm93c2VyQ29ubmVjdGlvbnMgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgYXV0b21hdGVkLCByZW1vdGVzIH0gPSBCb290c3RyYXBwZXIuX3NwbGl0QnJvd3NlckluZm8oYnJvd3NlckluZm8pO1xuXG4gICAgICAgIGlmIChyZW1vdGVzICYmIHJlbW90ZXMubGVuZ3RoICUgdGhpcy5jb25jdXJyZW5jeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90RGl2aWRlUmVtb3Rlc0NvdW50QnlDb25jdXJyZW5jeSk7XG5cbiAgICAgICAgbGV0IGJyb3dzZXJDb25uZWN0aW9ucyA9IHRoaXMuX2NyZWF0ZUF1dG9tYXRlZENvbm5lY3Rpb25zKGF1dG9tYXRlZCk7XG5cbiAgICAgICAgYnJvd3NlckNvbm5lY3Rpb25zID0gYnJvd3NlckNvbm5lY3Rpb25zLmNvbmNhdChjaHVuayhyZW1vdGVzLCB0aGlzLmNvbmN1cnJlbmN5KSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IEJyb3dzZXJTZXQuZnJvbShicm93c2VyQ29ubmVjdGlvbnMpO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRUZXN0cyAoKSB7XG4gICAgICAgIGNvbnN0IHsgcGFyc2VkRmlsZUxpc3QsIGNvbXBpbGVyT3B0aW9ucyB9ID0gYXdhaXQgdGhpcy5fZ2V0Q29tcGlsZXJBcmd1bWVudHMoKTtcblxuICAgICAgICBpZiAoIXBhcnNlZEZpbGVMaXN0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMudGVzdEZpbGVzTm90Rm91bmQpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHBhcnNlZEZpbGVMaXN0LCBjb21waWxlck9wdGlvbnMpO1xuICAgICAgICBsZXQgdGVzdHMgICAgICA9IGF3YWl0IGNvbXBpbGVyLmdldFRlc3RzKCk7XG5cbiAgICAgICAgY29uc3QgdGVzdHNXaXRoT25seUZsYWcgPSB0ZXN0cy5maWx0ZXIodGVzdCA9PiB0ZXN0Lm9ubHkpO1xuXG4gICAgICAgIGlmICh0ZXN0c1dpdGhPbmx5RmxhZy5sZW5ndGgpXG4gICAgICAgICAgICB0ZXN0cyA9IHRlc3RzV2l0aE9ubHlGbGFnO1xuXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcilcbiAgICAgICAgICAgIHRlc3RzID0gdGVzdHMuZmlsdGVyKHRlc3QgPT4gdGhpcy5maWx0ZXIodGVzdC5uYW1lLCB0ZXN0LmZpeHR1cmUubmFtZSwgdGVzdC5maXh0dXJlLnBhdGgsIHRlc3QubWV0YSwgdGVzdC5maXh0dXJlLm1ldGEpKTtcblxuICAgICAgICBpZiAoIXRlc3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMubm9UZXN0c1RvUnVuKTtcblxuICAgICAgICByZXR1cm4gdGVzdHM7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldENvbXBpbGVyQXJndW1lbnRzICgpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRmlsZUxpc3QgPSBhd2FpdCBwYXJzZUZpbGVMaXN0KHRoaXMuc291cmNlcywgcHJvY2Vzcy5jd2QoKSk7XG5cbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZVNjcmlwdE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0c0NvbmZpZ1BhdGg6IHRoaXMudHNDb25maWdQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHsgcGFyc2VkRmlsZUxpc3QsIGNvbXBpbGVyT3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGFzeW5jIF9lbnN1cmVPdXRTdHJlYW0gKG91dFN0cmVhbSkge1xuICAgICAgICBpZiAodHlwZW9mIG91dFN0cmVhbSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gb3V0U3RyZWFtO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxSZXBvcnRlck91dHB1dFBhdGggPSByZXNvbHZlUGF0aFJlbGF0aXZlbHlDd2Qob3V0U3RyZWFtKTtcblxuICAgICAgICBhd2FpdCBtYWtlRGlyKHBhdGguZGlybmFtZShmdWxsUmVwb3J0ZXJPdXRwdXRQYXRoKSk7XG5cbiAgICAgICAgcmV0dXJuIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZ1bGxSZXBvcnRlck91dHB1dFBhdGgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfYWRkRGVmYXVsdFJlcG9ydGVyIChyZXBvcnRlcnMpIHtcbiAgICAgICAgcmVwb3J0ZXJzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogJ3NwZWMnLFxuICAgICAgICAgICAgZmlsZTogcHJvY2Vzcy5zdGRvdXRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldFJlcG9ydGVyUGx1Z2lucyAoKSB7XG4gICAgICAgIGNvbnN0IHN0ZG91dFJlcG9ydGVycyA9IGZpbHRlcih0aGlzLnJlcG9ydGVycywgciA9PiBpc1VuZGVmaW5lZChyLm91dHB1dCkgfHwgci5vdXRwdXQgPT09IHByb2Nlc3Muc3Rkb3V0KTtcblxuICAgICAgICBpZiAoc3Rkb3V0UmVwb3J0ZXJzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLm11bHRpcGxlU3Rkb3V0UmVwb3J0ZXJzLCBzdGRvdXRSZXBvcnRlcnMubWFwKHIgPT4gci5uYW1lKS5qb2luKCcsICcpKTtcblxuICAgICAgICBpZiAoIXRoaXMucmVwb3J0ZXJzLmxlbmd0aClcbiAgICAgICAgICAgIEJvb3RzdHJhcHBlci5fYWRkRGVmYXVsdFJlcG9ydGVyKHRoaXMucmVwb3J0ZXJzKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5yZXBvcnRlcnMubWFwKGFzeW5jICh7IG5hbWUsIG91dHB1dCB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGx1Z2luRmFjdG9yeSA9IG5hbWU7XG5cbiAgICAgICAgICAgIGNvbnN0IG91dFN0cmVhbSA9IGF3YWl0IHRoaXMuX2Vuc3VyZU91dFN0cmVhbShvdXRwdXQpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbkZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5GYWN0b3J5ID0gcmVxdWlyZSgndGVzdGNhZmUtcmVwb3J0ZXItJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFJlcG9ydGVyRm9yQWxpYXMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbHVnaW46IHBsdWdpbkZhY3RvcnkoKSxcbiAgICAgICAgICAgICAgICBvdXRTdHJlYW1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBfc3RhcnRUZXN0ZWRBcHAgKCkge1xuICAgICAgICBpZiAodGhpcy5hcHBDb21tYW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0ZWRBcHAgPSBuZXcgVGVzdGVkQXBwKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IHRlc3RlZEFwcC5zdGFydCh0aGlzLmFwcENvbW1hbmQsIHRoaXMuYXBwSW5pdERlbGF5KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlc3RlZEFwcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGFzeW5jIF9jYW5Vc2VQYXJhbGxlbEJvb3RzdHJhcHBpbmcgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IGlzTG9jYWxQcm9taXNlcyA9IGJyb3dzZXJJbmZvLm1hcChicm93c2VyID0+IGJyb3dzZXIucHJvdmlkZXIuaXNMb2NhbEJyb3dzZXIobnVsbCwgYnJvd3NlckluZm8uYnJvd3Nlck5hbWUpKTtcbiAgICAgICAgY29uc3QgaXNMb2NhbEJyb3dzZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoaXNMb2NhbFByb21pc2VzKTtcblxuICAgICAgICByZXR1cm4gaXNMb2NhbEJyb3dzZXJzLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIF9ib290c3RyYXBTZXF1ZW5jZSAoYnJvd3NlckluZm8pIHtcbiAgICAgICAgY29uc3QgdGVzdHMgICAgICAgPSBhd2FpdCB0aGlzLl9nZXRUZXN0cygpO1xuICAgICAgICBjb25zdCB0ZXN0ZWRBcHAgICA9IGF3YWl0IHRoaXMuX3N0YXJ0VGVzdGVkQXBwKCk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJTZXQgID0gYXdhaXQgdGhpcy5fZ2V0QnJvd3NlckNvbm5lY3Rpb25zKGJyb3dzZXJJbmZvKTtcblxuICAgICAgICByZXR1cm4geyB0ZXN0cywgdGVzdGVkQXBwLCBicm93c2VyU2V0IH07XG4gICAgfVxuXG4gICAgX3dyYXBCb290c3RyYXBwaW5nUHJvbWlzZSAocHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+ICh7IGVycm9yOiBudWxsLCByZXN1bHQgfSkpXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gKHsgcmVzdWx0OiBudWxsLCBlcnJvciB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2hhbmRsZUJvb3RzdHJhcHBpbmdFcnJvciAoW2Jyb3dzZXJTZXRTdGF0dXMsIHRlc3RzU3RhdHVzLCB0ZXN0ZWRBcHBTdGF0dXNdKSB7XG4gICAgICAgIGlmICghYnJvd3NlclNldFN0YXR1cy5lcnJvcilcbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXJTZXRTdGF0dXMucmVzdWx0LmRpc3Bvc2UoKTtcblxuICAgICAgICBpZiAoIXRlc3RlZEFwcFN0YXR1cy5lcnJvciAmJiB0ZXN0ZWRBcHBTdGF0dXMucmVzdWx0KVxuICAgICAgICAgICAgYXdhaXQgdGVzdGVkQXBwU3RhdHVzLnJlc3VsdC5raWxsKCk7XG5cbiAgICAgICAgaWYgKHRlc3RzU3RhdHVzLmVycm9yKVxuICAgICAgICAgICAgdGhyb3cgdGVzdHNTdGF0dXMuZXJyb3I7XG4gICAgICAgIGVsc2UgaWYgKHRlc3RlZEFwcFN0YXR1cy5lcnJvcilcbiAgICAgICAgICAgIHRocm93IHRlc3RlZEFwcFN0YXR1cy5lcnJvcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgYnJvd3NlclNldFN0YXR1cy5lcnJvcjtcbiAgICB9XG5cbiAgICBhc3luYyBfYm9vdHN0cmFwUGFyYWxsZWwgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGxldCBib290c3RyYXBwaW5nUHJvbWlzZXMgPSBbXG4gICAgICAgICAgICB0aGlzLl9nZXRCcm93c2VyQ29ubmVjdGlvbnMoYnJvd3NlckluZm8pLFxuICAgICAgICAgICAgdGhpcy5fZ2V0VGVzdHMoKSxcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGVzdGVkQXBwKClcbiAgICAgICAgXTtcblxuICAgICAgICBib290c3RyYXBwaW5nUHJvbWlzZXMgPSBib290c3RyYXBwaW5nUHJvbWlzZXMubWFwKHByb21pc2UgPT4gdGhpcy5fd3JhcEJvb3RzdHJhcHBpbmdQcm9taXNlKHByb21pc2UpKTtcblxuICAgICAgICBjb25zdCBib290c3RyYXBwaW5nU3RhdHVzZXMgPSBhd2FpdCBQcm9taXNlLmFsbChib290c3RyYXBwaW5nUHJvbWlzZXMpO1xuXG4gICAgICAgIGlmIChib290c3RyYXBwaW5nU3RhdHVzZXMuc29tZShzdGF0dXMgPT4gc3RhdHVzLmVycm9yKSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZUJvb3RzdHJhcHBpbmdFcnJvcihib290c3RyYXBwaW5nU3RhdHVzZXMpO1xuXG4gICAgICAgIGNvbnN0IFticm93c2VyU2V0LCB0ZXN0cywgdGVzdGVkQXBwXSA9IGJvb3RzdHJhcHBpbmdTdGF0dXNlcy5tYXAoc3RhdHVzID0+IHN0YXR1cy5yZXN1bHQpO1xuXG4gICAgICAgIHJldHVybiB7IGJyb3dzZXJTZXQsIHRlc3RzLCB0ZXN0ZWRBcHAgfTtcbiAgICB9XG5cbiAgICAvLyBBUElcbiAgICBhc3luYyBjcmVhdGVSdW5uYWJsZUNvbmZpZ3VyYXRpb24gKCkge1xuICAgICAgICBjb25zdCByZXBvcnRlclBsdWdpbnMgICAgID0gYXdhaXQgdGhpcy5fZ2V0UmVwb3J0ZXJQbHVnaW5zKCk7XG4gICAgICAgIGNvbnN0IGNvbW1vbkNsaWVudFNjcmlwdHMgPSBhd2FpdCBsb2FkQ2xpZW50U2NyaXB0cyh0aGlzLmNsaWVudFNjcmlwdHMpO1xuXG4gICAgICAgIC8vIE5PVEU6IElmIGEgdXNlciBmb3Jnb3QgdG8gc3BlY2lmeSBhIGJyb3dzZXIsIGJ1dCBoYXMgc3BlY2lmaWVkIGEgcGF0aCB0byB0ZXN0cywgdGhlIHNwZWNpZmllZCBwYXRoIHdpbGwgYmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhcyB0aGUgYnJvd3NlciBhcmd1bWVudCwgYW5kIHRoZSB0ZXN0cyBwYXRoIGFyZ3VtZW50IHdpbGwgaGF2ZSB0aGUgcHJlZGVmaW5lZCBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAvLyBJdCdzIHZlcnkgYW1iaWd1b3VzIGZvciB0aGUgdXNlciwgd2hvIG1pZ2h0IGJlIGNvbmZ1c2VkIGJ5IGNvbXBpbGF0aW9uIGVycm9ycyBmcm9tIGFuIHVuZXhwZWN0ZWQgdGVzdC5cbiAgICAgICAgLy8gU28sIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIGJyb3dzZXIgYWxpYXNlcyBhbmQgcGF0aHMgYmVmb3JlIHRlc3RzIGNvbXBpbGF0aW9uLlxuICAgICAgICBjb25zdCBicm93c2VySW5mbyA9IGF3YWl0IHRoaXMuX2dldEJyb3dzZXJJbmZvKCk7XG5cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2NhblVzZVBhcmFsbGVsQm9vdHN0cmFwcGluZyhicm93c2VySW5mbykpXG4gICAgICAgICAgICByZXR1cm4geyByZXBvcnRlclBsdWdpbnMsIC4uLmF3YWl0IHRoaXMuX2Jvb3RzdHJhcFBhcmFsbGVsKGJyb3dzZXJJbmZvKSwgY29tbW9uQ2xpZW50U2NyaXB0cyB9O1xuXG4gICAgICAgIHJldHVybiB7IHJlcG9ydGVyUGx1Z2lucywgLi4uYXdhaXQgdGhpcy5fYm9vdHN0cmFwU2VxdWVuY2UoYnJvd3NlckluZm8pLCBjb21tb25DbGllbnRTY3JpcHRzIH07XG4gICAgfVxufVxuIl19